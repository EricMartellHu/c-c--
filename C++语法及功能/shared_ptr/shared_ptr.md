C++11标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则"独占"所指向的对象。C++11标准库还定义了一个名为weak_ptr的辅助类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。智能指针是模板类而不是指针。类似vector，智能指针也是模板，当创建一个智能指针时，必须提供额外的信息即指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空。


使用shared_ptr注意事项：

(1)、不要把一个原生指针给多个shared_ptr管理；

(2)、不要把this指针给shared_ptr；

(3)、不要在函数实参里创建shared_ptr；

(4)、不要不加思考地把指针替换为shared_ptr来防止内存泄漏，shared_ptr并不是万能的，而且使用它们的话也是需要一定的开销的；

(5)、环状的链式结构shared_ptr将会导致内存泄漏(可以结合weak_ptr来解决)；

(6)、共享拥有权的对象一般比限定作用域的对象生存更久，从而将导致更高的平均资源使用时间；

(7)、在多线程环境中使用共享指针的代价非常大，这是因为你需要避免关于引用计数的数据竞争；

(8)、共享对象的析构器不会在预期的时间执行；

(9)、不使用相同的内置指针值初始化(或reset)多个智能指针；

(10)、不delete get()返回的指针；

(11)、不使用get()初始化或reset另一个智能指针；

(12)、如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了；

(13)、如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。


C++11 中引入了智能指针, 同时还有一个模板函数 std::make_shared 可以返回一个指定类型的 std::shared_ptr

std::make_shared（比起直接使用new）的一个特性是能提升效率。使用std::make_shared允许编译器产生更小，更快的代码，产生的代码使用更简洁的数据结构。

std::shared_ptr<Widget> spw(new Widget);
很明显这段代码需要分配内存，但是它实际上要分配两次。每个std::shared_ptr都指向一个控制块，控制块包含被指向对象的引用计数以及其他东西。这个控制块的内存是在std::shared_ptr的构造函数中分配的。因此直接使用new，需要一块内存分配给Widget，还要一块内存分配给控制块。

auto spw = std::make_shared<Widget>();
一次分配就足够了。这是因为std::make_shared申请一个单独的内存块来同时存放Widget对象和控制块。这个优化减少了程序的静态大小，因为代码只包含一次内存分配的调用，并且这会加快代码的执行速度，因为内存只分配了一次。
另外，使用std::make_shared消除了一些控制块需要记录的信息，这样潜在地减少了程序的总内存占用。